#ifndef SECP256K1_ECDSA_ANTI_COVERT_CHANNEL_H
#define SECP256K1_ECDSA_ANTI_COVERT_CHANNEL_H

#include "secp256k1.h"

#ifdef __cplusplus
extern "C" {
#endif

/** Same as secp256k1_ecdsa_sign, but s2c_data32 is committed to by adding `hash(R1, s2c_data32)` to
 *  the nonce generated by noncefp, with `ndata=hash(s2c_data32, ndata)`.
 * In:
 *   s2c_opening: pointer to an secp256k1_s2c_opening structure which can be
 *                NULL but is required to be not NULL if this signature creates
 *                a sign-to-contract commitment (i.e. the `s2c_data` argument
 *                is not NULL). nonce_is_negated is always 0 for ecdsa.
 */
SECP256K1_API int secp256k1_ecdsa_s2c_sign(
    const secp256k1_context* ctx,
    secp256k1_ecdsa_signature *sig,
    secp256k1_s2c_opening *s2c_opening,
    const unsigned char *msg32,
    const unsigned char *seckey,
    secp256k1_nonce_function noncefp,
    const void *ndata,
    const unsigned char* s2c_data32
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);

/** Verify a sign-to-contract commitment.
 *
 *  Returns: 1: the signature contains a commitment to data32
 *           0: incorrect opening
 *  Args:    ctx: a secp256k1 context object, initialized for verification.
 *  In:      sig: the signature containing the sign-to-contract commitment (cannot be NULL)
 *        data32: the 32-byte data that was committed to (cannot be NULL)
 *       opening: pointer to the opening created during signing (cannot be NULL)
 */
SECP256K1_API int secp256k1_ecdsa_s2c_verify_commit(
    const secp256k1_context* ctx,
    const secp256k1_ecdsa_signature *sig,
    const unsigned char *data32,
    const secp256k1_s2c_opening *opening
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);

/** Compute commitment on the client as part of the ECDSA Anti Nonce Covert Channel Protocol.
 *
 * ECDSA Anti Nonce Covert Channel Protocol:
 * 1. The host draws randomness `k2`, commits to it with sha256 and sends the commitment to the client.
 * 2. The client commits to its original nonce `k1` using the host commitment by calling
 *    `secp256k1_ecdsa_anti_covert_channel_client_commit`. The client sends the resulting commitment
 *   `R1` to the host.
 * 3. The host replies with `k2` generated in step 1.
 * 4. The client signs with `secp256k1_ecdsa_s2c_sign`, using the `k2` as `s2c_data` and
 *    sends the signature and opening to the host.
 * 5. The host verifies that `R_x = (R1 + H(R1, k2)*G)_x`, where R_x is the `r` part of the signature by using
 *    `secp256k1_ecdsa_s2c_anti_nonce_covert_channel_host_verify` with the client's
 *     commitment from step 2 and the signature and opening received in step 4. If verification does
 *     not succeed, the protocol failed and can be restarted.
 *
 *  Returns 1 on success, 0 on failure.
 *  Args:           ctx: pointer to a context object (cannot be NULL)
 *  Out:  client_commit: pointer to a pubkey where the clients public nonce will be
 *                       placed. (cannot be NULL)
 *  In:           msg32: the 32-byte message hash to be signed (cannot be NULL)
 *             seckey32: the 32-byte secret key used for signing (cannot be NULL)
 *              noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used
 *    rand_commitment32: the 32-byte randomness commitment from the host (cannot be NULL)
 */
SECP256K1_API int secp256k1_ecdsa_s2c_anti_nonce_covert_channel_client_commit(
    const secp256k1_context* ctx,
    secp256k1_pubkey *client_commit,
    const unsigned char *msg32,
    const unsigned char *seckey32,
    unsigned char *rand_commitment32
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);

/** Create a randomness commitment on the host as part of the ECDSA Anti Nonce Covert Channel Protocol.
 *
 *  Returns 1 on success, 0 on failure.
 *  Args:              ctx: pointer to a context object (cannot be NULL)
 *  Out: rand_commitment32: pointer to 32-byte array to store the returned commitment (cannot be NULL)
 *  In:             rand32: the 32-byte randomness to commit to (cannot be NULL)
 */
SECP256K1_API int secp256k1_ecdsa_s2c_anti_nonce_covert_channel_host_commit(
    secp256k1_context *ctx,
    unsigned char *rand_commitment32,
    const unsigned char *rand32
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);

/** Verify that a clients signature contains the hosts randomness as part of the Anti
 *  Nonce Covert Channel Protocol. Does not verify the signature itself.
 *
 *  Returns 1 on success, 0 on failure.
 *  Args:         ctx: pointer to a context object (cannot be NULL)
 *  In:           sig: pointer to the signature whose randomness should be verified
 *                     (cannot be NULL)
 *             rand32: pointer to the 32-byte randomness from the host which should
 *                     be included by the signature (cannot be NULL)
 *            opening: pointer to the opening produced by the client when signing
 *                     with `rand32` as `s2c_data` (cannot be NULL)
 *      client_commit: pointer to the client's commitment created in
 *                     `secp256k1_ecdsa_s2c_anti_nonce_covert_channel_client_commit`
 *                     (cannot be NULL)
 */
SECP256K1_API int secp256k1_ecdsa_s2c_anti_nonce_covert_channel_host_verify(
    secp256k1_context *ctx,
    const secp256k1_ecdsa_signature *sig,
    const unsigned char *rand32,
    const secp256k1_s2c_opening *opening,
    const secp256k1_pubkey *client_commit
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);

#ifdef __cplusplus
}
#endif

#endif /* SECP256K1_RECOVERY_H */
